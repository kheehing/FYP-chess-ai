
import chess
import chess.engine
import numpy as np
import keras
import matplotlib.pyplot as plt

# Loading Keras model
model = keras.models.load_model('keras-model/1000.keras')

# Initialize Stockfish instances for different ELO levels
stockfish_1000 = chess.engine.SimpleEngine.popen_uci("C:/Users/light/Downloads/stockfish-windows-x86-64-avx2/stockfish/stockfish-windows-x86-64-avx2.exe")
stockfish_1000.configure({"Skill Level": 10, "Threads": 1, "Hash": 128})

stockfish_2000 = chess.engine.SimpleEngine.popen_uci("C:/Users/light/Downloads/stockfish-windows-x86-64-avx2/stockfish/stockfish-windows-x86-64-avx2.exe")
stockfish_2000.configure({"Skill Level": 15, "Threads": 2, "Hash": 256})

stockfish_3000 = chess.engine.SimpleEngine.popen_uci("C:/Users/light/Downloads/stockfish-windows-x86-64-avx2/stockfish/stockfish-windows-x86-64-avx2.exe")
stockfish_3000.configure({"Skill Level": 20, "Threads": 4, "Hash": 512})

def get_stockfish_move(board, stockfish, depth=15):
    # Using chess.engine to calculate the best move
    with stockfish.analysis(board, chess.engine.Limit(depth=depth)) as analysis:
        for info in analysis:
            if 'pv' in info and info['pv']:
                move = info['pv'][0]
                return move
    return None

def get_model_move(board, model):
    try:
        # Convert the board state to the input format required by the model
        # This might involve converting the board to FEN or another representation
        input_data = board.fen()  # Example: using FEN format

        # Use the model to predict the best move (assuming the model outputs a UCI move)
        predicted_move_uci = model.predict(input_data)  # Adjust this according to your model's prediction method

        # Convert the predicted UCI move to a chess.Move object
        move = chess.Move.from_uci(predicted_move_uci)

        # Check if the move is legal
        if move in board.legal_moves:
            return move
        else:
            print(f"Illegal move generated by model: {predicted_move_uci}")
            return None
    except Exception as e:
        print(f"Model error: {e}")
        return None


# Test the rotation of Stockfish and model as White and Black
def test_model_vs_stockfish(stockfish_instances, model, rounds=10):
    for i in range(rounds):
        board = chess.Board()
        white_player = model if i % 2 == 0 else stockfish_instances[i % 3]
        black_player = stockfish_instances[i % 3] if i % 2 == 0 else model

        while not board.is_game_over():
            if board.turn == chess.WHITE:
                move = get_model_move(board, white_player) if white_player == model else get_stockfish_move(board, white_player)
            else:
                move = get_model_move(board, black_player) if black_player == model else get_stockfish_move(board, black_player)

            if move and move in board.legal_moves:
                board.push(move)
            else:
                print(f"Illegal move: {move} in position {board.fen()}")
                break

        print(f"Game {i+1}: Result - {board.result()}")

# List of Stockfish instances
stockfish_instances = [stockfish_1000, stockfish_2000, stockfish_3000]

# Run the tests
test_model_vs_stockfish(stockfish_instances, model)
